<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ann Arbor Parking Citations Map</title>

    <!-- Meta Tags for Rich Previews -->
    <meta
      name="description"
      content="Interactive map of Ann Arbor parking citations"
    />
    <meta name="author" content="ammar ateya" />

    <!-- Open Graph Tags -->
    <meta property="og:title" content="Ann Arbor Parking Citations Map" />
    <meta
      property="og:description"
      content="Interactive map showing parking citations across Ann Arbor, MI. Real-time tracking of parking tickets with search and notifications."
    />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="{{ og_url }}" />
    <meta property="og:image" content="{{ og_image }}" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:type" content="image/png" />
    <meta property="og:site_name" content="Ann Arbor Parking Citations" />

    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Ann Arbor Parking Citations Map" />
    <meta
      name="twitter:description"
      content="Interactive map showing parking citations across Ann Arbor, MI. Real-time tracking of parking tickets with search and notifications."
    />
    <meta name="twitter:image" content="{{ og_image }}" />

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/icon.png" />
    <link rel="apple-touch-icon" href="/icon.png" />

    <!-- Google Analytics -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-J001JG2NJ1"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());
      gtag("config", "G-J001JG2NJ1");
    </script>

    <!-- Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Custom text selection - vibrant magenta */
      ::selection {
        background: rgba(255, 0, 170, 0.35);
        color: #0a0a0a;
      }
      ::-moz-selection {
        background: rgba(255, 0, 170, 0.35);
        color: #0a0a0a;
      }

      body {
        font-family: "SF Mono", "Monaco", "Menlo", "Consolas", "Liberation Mono",
          monospace;
        background: #0a0a0a;
        overflow: hidden;
        height: 100vh;
        width: 100vw;
        position: relative;
      }

      /* Scan line effect */
      body::before {
        content: "";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: repeating-linear-gradient(
          0deg,
          rgba(0, 255, 0, 0.03),
          rgba(0, 255, 0, 0.03) 1px,
          transparent 1px,
          transparent 2px
        );
        pointer-events: none;
        z-index: 9999;
        animation: scan 8s linear infinite;
      }

      @keyframes scan {
        0% {
          transform: translateY(0);
        }
        100% {
          transform: translateY(4px);
        }
      }

      #map {
        height: 100vh;
        width: 100vw;
        margin-left: 0;
        position: fixed;
        z-index: 1;
        transition: width 0.3s ease, margin-left 0.3s ease;
      }

      body.panel-open #map {
        width: calc(100vw - 400px);
        margin-left: 400px;
      }

      /* Header - Retro Terminal Style */
      .header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: #0a0a0a;
        border-bottom: 3px solid #00ff00;
        z-index: 1000;
        padding: 10px 20px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-family: "Press Start 2P", cursive;
        box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
      }

      body.panel-open .header {
        left: 400px;
      }

      .header-title {
        color: #00ff00;
        font-size: 10px;
        text-shadow: 0 0 10px #00ff00;
        letter-spacing: 2px;
      }

      .header-status {
        color: #00ff00;
        font-size: 8px;
        animation: blink 1s infinite;
      }

      /* Info box/link */
      .info-link {
        position: fixed;
        top: 48px;
        right: 20px;
        background: rgba(10, 10, 10, 0.95);
        border: 2px solid #00ff00;
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 999;
        text-decoration: none;
        color: #00ff00;
        font-size: 11px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        transition: all 0.2s ease;
        box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
      }

      .info-link:hover {
        background: #00ff00;
        color: #0a0a0a;
        box-shadow: 0 4px 20px rgba(0, 255, 0, 0.5);
      }

      .info-icon {
        width: 16px;
        height: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid currentColor;
        border-radius: 50%;
        font-size: 11px;
        font-weight: bold;
      }

      @media (max-width: 768px) {
        .info-link {
          top: 70px;
          right: 10px;
          padding: 6px 10px;
          font-size: 10px;
        }

        .info-icon {
          width: 14px;
          height: 14px;
          font-size: 10px;
        }

        /* Mobile: show only the info icon, hide text */
        .info-link span:nth-child(2) {
          display: none !important;
        }
        .info-link {
          padding: 4px 6px !important;
          border-width: 2px !important;
        }
      }

      @keyframes blink {
        0%,
        50% {
          opacity: 1;
        }
        51%,
        100% {
          opacity: 0.3;
        }
      }

      /* Statistics bar - Circuit board style */
      .stats-bar {
        position: fixed;
        top: 94px;
        left: 0;
        right: 0;
        background: #0a0a0a;
        border-bottom: 2px solid #00ff00;
        z-index: 999;
        padding: 12px 20px;
        display: flex;
        gap: 40px;
        justify-content: flex-start;
        align-items: center;
      }

      body.panel-open .stats-bar {
        left: 400px;
      }

      .stat-item {
        text-align: left;
      }

      .stat-value {
        color: #00ff00;
        font-size: 16px;
        font-weight: bold;
        display: block;
        text-shadow: 0 0 5px #00ff00;
      }

      .stat-label {
        color: #888;
        font-size: 9px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-top: 2px;
      }

      /* Side panel - Retro terminal */
      .side-panel {
        position: fixed;
        top: 0;
        left: 0;
        width: 400px;
        height: 100vh;
        background: #0a0a0a;
        border-right: 3px solid #00ff00;
        z-index: 1001;
        overflow-y: auto;
        box-shadow: 4px 0 20px rgba(0, 255, 0, 0.3);
        display: none;
      }

      .side-panel.active {
        display: block;
      }

      .side-panel-header {
        padding: 15px;
        border-bottom: 2px solid #00ff00;
        background: #0a0a0a;
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .side-panel-title {
        color: #00ff00;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      .side-panel-content {
        padding: 15px;
        color: #00ff00;
        line-height: 1.8;
      }

      .info-item {
        padding: 10px 0;
        border-bottom: 1px solid rgba(0, 255, 0, 0.2);
      }

      .info-label {
        color: #888;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 5px;
      }

      .info-value {
        color: #00ff00;
        font-size: 12px;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
      }

      /* Map controls */
      .map-controls {
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(10, 10, 10, 0.95);
        border: 2px solid #00ff00;
        padding: 10px;
        display: flex;
        gap: 8px;
        z-index: 1000;
        box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
      }

      body.panel-open .map-controls {
        left: 450px;
      }

      /* Legend styles */
      .legend {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: rgba(10, 10, 10, 0.95);
        border: 2px solid #00ff00;
        padding: 12px;
        z-index: 1000;
        box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
        min-width: 180px;
      }

      /* Keep legend docked right even when side panel is open */
      body.panel-open .legend {
        right: 20px;
      }

      .legend-header {
        color: #00ff00;
        font-size: 10px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid rgba(0, 255, 0, 0.3);
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 8px 0;
      }

      .legend-marker {
        width: 12px;
        height: 12px;
        border-radius: 0;
      }

      .legend-text {
        color: #00ff00;
        font-size: 11px;
        font-weight: bold;
        letter-spacing: 0.5px;
      }

      .legend-text span {
        color: #00ff00;
        text-shadow: 0 0 5px #00ff00;
      }

      @media (max-width: 768px) {
        .legend {
          display: none !important;
        }
      }

      .control-btn {
        background: #0a0a0a;
        border: 2px solid #00ff00;
        color: #00ff00;
        font-size: 11px;
        font-weight: bold;
        padding: 8px 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .control-btn:hover {
        background: #00ff00;
        color: #0a0a0a;
        text-shadow: none;
      }

      .control-btn.active {
        background: #00ff00;
        color: #0a0a0a;
      }

      /* Search dropdown/select styling */
      .select-control {
        background: #0a0a0a;
        border: 2px solid #00ff00;
        color: #00ff00;
        font-size: 10px;
        font-weight: bold;
        padding: 6px 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
      }

      .search-input {
        background: #0a0a0a;
        border: 2px solid #00ff00;
        color: #00ff00;
        padding: 6px 8px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        font-size: 11px;
        letter-spacing: 0.5px;
      }

      .search-input::placeholder {
        color: #00ff00;
        opacity: 0.45;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
        letter-spacing: 0.5px;
      }

      .search-input.highlight {
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }

      /* Dropdown chevron indicator */
      .select-wrap {
        position: relative;
        display: inline-block;
      }
      .select-wrap:after {
        content: "▾";
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        color: #00ff00;
        pointer-events: none;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
      }
      .select-control {
        padding-right: 28px; /* room for chevron */
      }

      /* Popup modal */
      .modal {
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.4);
        z-index: 2000;
        animation: fadeIn 0.3s ease;
      }

      .modal.active {
        display: flex;
        flex-direction: column;
      }

      .modal-content {
        background: rgba(20, 20, 20, 0.95);
        backdrop-filter: blur(40px);
        -webkit-backdrop-filter: blur(40px);
        border-radius: 28px 28px 0 0;
        padding: 24px;
        max-height: 70vh;
        overflow-y: auto;
        animation: slideUp 0.3s ease;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 16px;
        border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
      }

      .modal-title {
        color: #fff;
        font-size: 22px;
        font-weight: 700;
        letter-spacing: -0.5px;
      }

      .close-btn {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        color: #fff;
        width: 32px;
        height: 32px;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 20px;
        transition: all 0.2s ease;
      }

      .close-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .modal-body {
        color: #fff;
      }

      .info-row {
        padding: 12px 0;
        border-bottom: 0.5px solid rgba(255, 255, 255, 0.1);
      }

      .info-row:last-child {
        border-bottom: none;
      }

      .info-label {
        color: rgba(255, 255, 255, 0.6);
        font-size: 13px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 4px;
      }

      .info-value {
        color: #fff;
        font-size: 17px;
        font-weight: 600;
      }

      /* Loading indicator - Flashing alarm style */
      .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(10, 10, 10, 0.95);
        color: #00ff00;
        padding: 20px 30px;
        border: 3px solid #00ff00;
        border-radius: 0;
        z-index: 3000;
        font-size: 15px;
        font-weight: bold;
        font-family: "Press Start 2P", cursive;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 0 10px #00ff00;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.5),
          inset 0 0 20px rgba(0, 255, 0, 0.1);
        animation: alarmFlash 0.5s infinite;
      }

      @keyframes alarmFlash {
        0%,
        50% {
          border-color: #00ff00;
          color: #00ff00;
          text-shadow: 0 0 10px #00ff00;
          box-shadow: 0 0 20px rgba(0, 255, 0, 0.5),
            inset 0 0 20px rgba(0, 255, 0, 0.1);
        }
        51%,
        100% {
          border-color: #ff0040;
          color: #ff0040;
          text-shadow: 0 0 10px #ff0040;
          box-shadow: 0 0 20px rgba(255, 0, 64, 0.5),
            inset 0 0 20px rgba(255, 0, 64, 0.1);
        }
      }

      /* Time filter bar */
      .time-filter-bar {
        position: fixed;
        top: 48px;
        left: 0;
        right: 0;
        background: #0a0a0a;
        border-bottom: 2px solid #00ff00;
        z-index: 998;
        padding: 14px 20px 12px 20px;
        display: flex;
        gap: 12px;
        justify-content: flex-start;
        align-items: center;
      }

      body.panel-open .time-filter-bar {
        left: 400px;
      }

      .time-filter-label {
        color: #888;
        font-size: 9px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-right: 8px;
      }

      .time-filter-btn {
        background: #0a0a0a;
        border: 2px solid #00ff00;
        color: #00ff00;
        font-size: 10px;
        font-weight: bold;
        padding: 6px 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-family: "Press Start 2P", cursive;
      }

      .time-filter-btn:hover {
        background: #00ff00;
        color: #0a0a0a;
        text-shadow: none;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }

      .time-filter-btn.active {
        background: #00ff00;
        color: #0a0a0a;
        box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }

      /* No results message - Flashing style */
      .no-results-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(10, 10, 10, 0.95);
        color: #00ff00;
        padding: 20px 30px;
        border: 3px solid #00ff00;
        border-radius: 0;
        z-index: 3000;
        font-size: 12px;
        font-weight: bold;
        font-family: "Press Start 2P", cursive;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-shadow: 0 0 10px #00ff00;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.5),
          inset 0 0 20px rgba(0, 255, 0, 0.1);
        animation: alarmFlash 0.5s infinite;
        display: none;
        text-align: center;
      }

      .no-results-message.visible {
        display: block;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      @keyframes slideUp {
        from {
          transform: translateY(100%);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      /* Hint flash animation (3 blinks) */
      @keyframes hintFlash {
        0% {
          opacity: 0;
        }
        20% {
          opacity: 1;
        }
        50% {
          opacity: 0;
        }
        70% {
          opacity: 1;
        }
        100% {
          opacity: 0;
        }
      }
      #searchHint.flash {
        animation: hintFlash 0.6s ease-in-out 3;
      }

      /* Custom marker styles - Minimal terminal dots */
      .custom-marker {
        width: 10px;
        height: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .custom-marker:hover {
        transform: scale(1.5);
        box-shadow: 0 0 8px currentColor !important;
      }

      /* Custom popup style - Terminal aesthetic */
      .leaflet-popup-content-wrapper {
        background: #0a0a0a;
        border: 2px solid #00ff00;
        border-radius: 0;
        color: #00ff00;
        padding: 0;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.5),
          inset 0 0 20px rgba(0, 255, 0, 0.1);
      }

      .leaflet-popup-tip {
        background: #0a0a0a;
        border: 2px solid #00ff00;
        border-top: none;
      }

      .leaflet-popup-content {
        margin: 0;
        padding: 12px 15px;
        line-height: 1.6;
        font-size: 11px;
        font-weight: bold;
        text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
      }

      .leaflet-popup-content strong {
        color: #00ff00;
        display: block;
        margin-bottom: 6px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .leaflet-popup-content br {
        display: block;
        margin: 4px 0;
      }

      .leaflet-container a.leaflet-popup-close-button {
        color: #00ff00;
        padding: 8px;
        font-size: 18px;
        font-weight: bold;
        text-shadow: 0 0 5px #00ff00;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        right: 5px;
        top: 5px;
      }

      .leaflet-container a.leaflet-popup-close-button:hover {
        color: #0a0a0a;
        background: #00ff00;
        text-shadow: none;
      }

      /* Mobile responsive styles */
      @media (max-width: 768px) {
        .header-title {
          font-size: 16px;
        }

        .time-filter-bar {
          top: 62px;
          padding: 8px 3px 8px 3px;
          gap: 4px;
        }

        .time-filter-btn {
          font-size: 9px !important;
          padding: 2px 7px !important;
          min-width: 34px !important;
          max-width: 44px;
          border-width: 2px !important;
          line-height: 12px;
          letter-spacing: 0.2px;
        }

        .stats-bar {
          font-size: 10px;
          padding: 8px 12px;
          top: 100px; /* Directly attached below time-filter-bar: 62px (top) + 8px (top padding) + ~20px (button height) + 8px (bottom padding) + 2px (border) = 100px */
        }

        .stat-item {
          font-size: 11px;
        }

        .side-panel {
          width: 100%;
          position: fixed;
          left: 0;
          right: 0;
          height: 33vh; /* Take up about 1/3 of screen */
          bottom: -33vh; /* Start hidden below viewport */
          top: auto;
          border-right: none;
          border-top: 3px solid #00ff00;
          z-index: 1001;
          transition: bottom 0.3s ease-out;
          display: block; /* Always rendered, just positioned off-screen */
          overflow-y: auto; /* Allow scrolling if content overflows */
          max-height: 33vh; /* Ensure it doesn't exceed viewport */
        }

        .side-panel.active {
          bottom: 0; /* Slide up to bottom of viewport */
        }

        /* On mobile, prevent layout shift when panel opens */
        body.panel-open #map {
          width: 100vw !important;
          margin-left: 0 !important;
        }

        body.panel-open .header {
          left: 0 !important;
        }

        body.panel-open .stats-bar {
          left: 0 !important;
        }

        body.panel-open .time-filter-bar {
          left: 0 !important;
        }

        #map {
          width: 100vw;
          height: 100vh;
          margin-left: 0;
        }

        .map-controls {
          left: 10px;
          bottom: 10px;
          flex-direction: column;
          gap: 8px;
          transition: bottom 0.3s ease-out;
        }
        
        /* When panel is active on mobile, move controls up */
        body.mobile-panel-open .map-controls {
          bottom: calc(33vh + 10px);
        }

        .control-btn {
          font-size: 10px;
          padding: 8px 10px;
        }

        .leaflet-popup-content {
          font-size: 12px;
          padding: 10px;
        }

        .leaflet-popup-content strong {
          font-size: 13px;
        }

        .info-item {
          padding: 8px 0;
        }

        .info-label {
          font-size: 9px;
        }

        .info-value {
          font-size: 11px;
        }
      }

      /* Mobile: hide legend for simpler experience */
      @media (max-width: 768px) {
        .legend {
          display: none !important;
        }
        /* Search panel and notify panel compacting */
        .map-controls #searchPanel,
        .map-controls #notifyPanel {
          padding: 4px 2px 4px 2px !important;
          gap: 2px !important;
          flex-wrap: wrap;
          font-size: 10px !important;
        }
        .select-control,
        .search-input {
          font-size: 10px !important;
          padding: 3px 6px !important;
          min-width: 40px;
          height: 28px !important;
        }
        .control-btn,
        .time-filter-btn {
          font-size: 9px !important;
          padding: 5px 7px !important;
          min-width: 22px;
          height: 28px !important;
          border-width: 1.5px !important;
        }
        /* Make action text smaller on mobile (PICK / NEAR ME / +/-) */
        #pickLocationBtn,
        #useMyLocationBtn,
        #notifyPickCenterBtn,
        #notifyUseMyLocationBtn,
        #searchRadiusMinus,
        #searchRadiusPlus,
        #notifyRadiusMinus,
        #notifyRadiusPlus {
          font-size: 8px !important;
          padding: 2px 6px !important;
          letter-spacing: 0.2px !important;
        }
        /* Ensure PICK buttons fit their text fully */
        #pickLocationBtn,
        #notifyPickCenterBtn {
          min-width: auto !important;
          width: auto !important;
          white-space: nowrap !important;
          padding: 3px 8px !important;
          line-height: 12px !important;
        }
        #searchPickedLocationText,
        #notifyPickedText {
          font-size: 9px !important;
          max-width: 70vw;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        /* Ensure search action buttons have enough room */
        #searchBtn {
          min-width: 48px !important;
          white-space: nowrap !important;
        }
        #clearSearchBtn {
          min-width: 64px !important;
          padding: 4px 10px !important;
          white-space: nowrap !important;
        }
        /* Ensure SUBSCRIBE button fits content */
        #notifySubmitBtn {
          min-width: auto !important;
          width: auto !important;
          max-width: none !important;
          white-space: nowrap !important;
          padding: 4px 10px !important;
          line-height: 12px !important;
        }
      }
    </style>
  </head>
  <body>
    <!-- Side Panel -->
    <div class="side-panel" id="sidePanel">
      <div
        class="side-panel-header"
        style="
          display: flex;
          align-items: center;
          justify-content: space-between;
        "
      >
        <div class="side-panel-title" id="sidePanelTitle">CITATION DETAILS</div>
        <button
          class="control-btn"
          style="padding: 4px 8px; font-size: 10px"
          onclick="closeSidePanel()"
        >
          CLOSE
        </button>
      </div>
      <div class="side-panel-content" id="sidePanelContent">
        <div class="info-item">
          <div class="info-label">SELECT A MARKER</div>
          <div class="info-value">
            Click on a citation marker to view details
          </div>
        </div>
      </div>
    </div>

    <div id="map"></div>

    <div class="header">
      <div class="header-title">ANN ARBOR PARKING CITATIONS</div>
      <div
        style="
          display: flex;
          flex-direction: column;
          align-items: flex-end;
          gap: 4px;
        "
      >
        <div class="header-status">● ONLINE</div>
        <div
          class="header-recent-time"
          id="recentCitationTime"
          style="
            color: #fff;
            font-size: 10px;
            letter-spacing: 0;
            min-height: 14px;
            white-space: nowrap;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
              'Liberation Mono', 'Courier New', monospace;
          "
        ></div>
      </div>
    </div>

    <a href="/a2-parking/about/" class="info-link" title="How does this work?">
      <span class="info-icon">?</span>
      <span>How does this work?</span>
    </a>

    <!-- search bar removed; replaced by map-controls search toggle -->

    <div class="time-filter-bar" id="timeFilterBar">
      <span class="time-filter-label">VIEW:</span>
      <button
        class="time-filter-btn"
        onclick="filterByTime('all')"
        id="filterAll"
        data-time="all"
      >
        ALL
      </button>
      <button
        class="time-filter-btn"
        onclick="filterByTime('week')"
        id="filterWeek"
        data-time="week"
      >
        PAST WEEK
      </button>
      <button
        class="time-filter-btn"
        onclick="filterByTime('day')"
        id="filterDay"
        data-time="day"
      >
        PAST 24 HOURS
      </button>
      <button
        class="time-filter-btn"
        onclick="filterByTime('hour')"
        id="filterHour"
        data-time="hour"
      >
        PAST HOUR
      </button>
    </div>

    <div class="stats-bar" id="statsBar">
      <div class="stat-item">
        <span class="stat-label">TOTAL CITATIONS</span>
        <span class="stat-value" id="totalCitations">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">TOTAL AMOUNT</span>
        <span class="stat-value" id="totalAmount">$0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">CITATIONS TODAY</span>
        <span class="stat-value" id="totalCitationsToday">0</span>
      </div>
      <div class="stat-item">
        <span class="stat-label">AMOUNT TODAY</span>
        <span class="stat-value" id="totalAmountToday">$0</span>
      </div>
    </div>

    <!-- Mobile: legend directly below stats bar -->
    <div class="legend" id="legendBar">
      <div class="legend-header">LEGEND</div>
      <div class="legend-items-row">
        <div class="legend-item">
          <div
            class="legend-marker"
            style="background: rgba(255, 0, 64, 0.7); border: 1px solid #ff0040"
          ></div>
          <span class="legend-text">>= $50: <span id="legendRed">0</span></span>
        </div>
        <div class="legend-item">
          <div
            class="legend-marker"
            style="
              background: rgba(255, 128, 0, 0.7);
              border: 1px solid #ff8000;
            "
          ></div>
          <span class="legend-text"
            >>= $30: <span id="legendOrange">0</span></span
          >
        </div>
        <div class="legend-item">
          <div
            class="legend-marker"
            style="background: rgba(0, 255, 0, 0.7); border: 1px solid #00ff00"
          ></div>
          <span class="legend-text"
            >< $30: <span id="legendGreen">0</span></span
          >
        </div>
      </div>
    </div>

    <div class="map-controls">
      <button
        class="control-btn"
        onclick="resetView()"
        id="resetBtn"
        title="Reset view"
        aria-label="Reset view"
      >
        <svg
          width="18"
          height="18"
          viewBox="0 0 24 24"
          fill="none"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M12 6V3L8 7l4 4V8c2.757 0 5 2.243 5 5s-2.243 5-5 5-5-2.243-5-5H5c0 3.866 3.134 7 7 7s7-3.134 7-7-3.134-7-7-7z"
            fill="#00ff00"
          />
        </svg>
      </button>
      <button
        class="control-btn"
        onclick="toggleTheme()"
        id="themeBtn"
        title="Toggle theme"
        aria-label="Toggle theme"
      >
        <!-- icon set by script -->
      </button>
      <button
        class="control-btn"
        id="searchToggleBtn"
        title="Search"
        aria-label="Search"
      >
        <!-- icon set by script -->
      </button>
      <div
        id="searchPanel"
        style="
          display: none;
          background: #0a0a0a;
          border: 2px solid #00ff00;
          padding: 8px;
          gap: 6px;
          align-items: center;
        "
      >
        <span class="select-wrap">
          <select id="searchMode" class="select-control">
            <option value="plate">PLATE</option>
            <option value="citation">CITATION #</option>
            <option value="location">LOCATION</option>
          </select>
        </span>
        <span
          id="plateInputs"
          style="display: inline-flex; gap: 6px; align-items: center"
        >
          <input
            id="searchPlateState"
            placeholder="MI"
            maxlength="2"
            class="search-input"
            style="width: 56px; text-transform: uppercase"
          />
          <input
            id="searchPlateNumber"
            placeholder="GOBLUE"
            class="search-input"
            style="min-width: 120px; width: 140px"
          />
        </span>
        <span id="citationInputs" style="display: none">
          <input
            id="searchCitationNumber"
            placeholder="CITATION #"
            class="search-input"
            style="min-width: 160px"
          />
        </span>
        <span
          id="locationInputs"
          style="display: none; align-items: center; gap: 6px"
        >
          <button
            class="time-filter-btn"
            id="pickLocationBtn"
            title="Pick center on map"
          >
            PICK
          </button>
          <button
            class="time-filter-btn"
            id="useMyLocationBtn"
            title="Use my current location"
          >
            NEAR ME
          </button>
          <input
            id="searchRadiusMeters"
            type="number"
            min="10"
            max="100000"
            value="250"
            step="10"
            class="search-input"
            style="width: 100px"
          />
          <button
            class="time-filter-btn"
            id="searchRadiusMinus"
            title="decrease radius"
          >
            −
          </button>
          <button
            class="time-filter-btn"
            id="searchRadiusPlus"
            title="increase radius"
          >
            +
          </button>
          <span class="time-filter-label">RADIUS (m)</span>
          <span
            id="searchPickedLocationText"
            style="color: #888; font-size: 10px; margin-left: 6px"
            >center: none</span
          >
        </span>
        <button class="time-filter-btn" id="searchBtn">GO</button>
        <button class="time-filter-btn" id="clearSearchBtn">CLEAR</button>
      </div>
      <button
        class="control-btn"
        id="notifyToggleBtn"
        title="Notifications"
        aria-label="Notifications"
      >
        <!-- bell icon set by script -->
      </button>
      <div
        id="notifyPanel"
        style="
          display: none;
          background: #0a0a0a;
          border: 2px solid #00ff00;
          padding: 8px;
          gap: 6px;
          align-items: flex-start;
          flex-direction: column;
        "
      >
        <div style="display: flex; gap: 8px; align-items: center">
          <span class="time-filter-label">SUBSCRIBE:</span>
          <span class="select-wrap">
            <select id="notifyMode" class="select-control">
              <option value="plate">PLATE</option>
              <option value="location">LOCATION</option>
            </select>
          </span>
        </div>
        <div
          id="notifyPlate"
          style="display: flex; gap: 6px; align-items: center"
        >
          <input
            id="notifyPlateState"
            placeholder="MI"
            maxlength="2"
            class="search-input"
            style="width: 56px; text-transform: uppercase"
          />
          <input
            id="notifyPlateNumber"
            placeholder="GOBLUE"
            class="search-input"
            style="min-width: 120px; width: 140px"
          />
        </div>
        <div
          id="notifyLocation"
          style="display: none; gap: 6px; align-items: center; flex-wrap: wrap"
        >
          <button
            class="time-filter-btn"
            id="notifyPickCenterBtn"
            title="Pick center on map"
          >
            PICK
          </button>
          <button
            class="time-filter-btn"
            id="notifyUseMyLocationBtn"
            title="Use my current location"
          >
            NEAR ME
          </button>
          <input
            id="notifyRadiusMeters"
            type="number"
            min="10"
            max="100000"
            value="250"
            step="10"
            class="search-input"
            style="width: 100px"
          />
          <button
            class="time-filter-btn"
            id="notifyRadiusMinus"
            title="decrease radius"
          >
            −
          </button>
          <button
            class="time-filter-btn"
            id="notifyRadiusPlus"
            title="increase radius"
          >
            +
          </button>
          <span class="time-filter-label">RADIUS (m)</span>
          <span
            id="notifyPickedText"
            style="color: #888; font-size: 10px; margin-left: 6px"
            >center: none</span
          >
        </div>
        <div
          style="display: flex; gap: 6px; align-items: center; flex-wrap: wrap"
        >
          <input
            id="notifyEmail"
            placeholder="Email (required)"
            class="search-input"
            style="min-width: 200px"
          />
          <button class="time-filter-btn" id="notifySubmitBtn">
            SUBSCRIBE
          </button>
        </div>
        <div id="notifyMsg" style="font-size: 10px; color: #888"></div>
      </div>
    </div>

    <!-- Location search hint overlay -->
    <div
      id="searchHint"
      style="
        display: none;
        position: fixed;
        bottom: 100px;
        left: 20px;
        background: rgba(10, 10, 10, 0.95);
        border: 2px solid #00ff00;
        padding: 10px 12px;
        color: #00ff00;
        z-index: 1200;
        box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
        font-weight: bold;
        font-size: 11px;
      "
    >
      CLICK MAP TO SET CENTER • ADJUST RADIUS • PRESS GO
    </div>

    <div class="loading" id="loading">LOADING CITATIONS...</div>

    <div class="no-results-message" id="noResultsMessage">
      <div>NONE FOUND</div>
      <div
        style="font-size: 10px; margin-top: 10px; opacity: 0.8"
        id="noResultsInterval"
      ></div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
      function closeSidePanel() {
        const panel = document.getElementById("sidePanel");
        panel.classList.remove("active");
        // Check if mobile
        const isMobile = window.matchMedia && window.matchMedia("(max-width: 768px)").matches;
        if (isMobile) {
          document.body.classList.remove("mobile-panel-open");
        } else {
          document.body.classList.remove("panel-open");
        }
      }
      // Initialize map centered on Ann Arbor
      const map = L.map("map", {
        zoomControl: true,
        zoom: 13,
        center: [42.2808, -83.743],
        preferCanvas: true,
      });

      let isDarkMode = true;
      let currentTileLayer;

      // Side panel closed by default

      // Initialize with dark theme
      currentTileLayer = L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
        {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
          subdomains: "abcd",
          maxZoom: 20,
        }
      ).addTo(map);

      // Icon helpers
      function getSunIcon() {
        return '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">\
          <circle cx="12" cy="12" r="4" fill="#00ff00"/>\
          <g stroke="#00ff00" stroke-width="2">\
            <line x1="12" y1="1" x2="12" y2="4"/>\
            <line x1="12" y1="20" x2="12" y2="23"/>\
            <line x1="1" y1="12" x2="4" y2="12"/>\
            <line x1="20" y1="12" x2="23" y2="12"/>\
            <line x1="4.22" y1="4.22" x2="6.34" y2="6.34"/>\
            <line x1="17.66" y1="17.66" x2="19.78" y2="19.78"/>\
            <line x1="4.22" y1="19.78" x2="6.34" y2="17.66"/>\
            <line x1="17.66" y1="6.34" x2="19.78" y2="4.22"/>\
          </g>\
        </svg>';
      }

      function getMoonIcon() {
        return '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">\
          <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" fill="#00ff00"/>\
        </svg>';
      }

      function getSearchIcon() {
        return '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">\
          <circle cx="11" cy="11" r="7" stroke="#00ff00" stroke-width="2" fill="none"/>\
          <line x1="16.5" y1="16.5" x2="22" y2="22" stroke="#00ff00" stroke-width="2"/>\
        </svg>';
      }

      function getBellIcon() {
        return '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">\
          <path d="M12 22a2 2 0 002-2H10a2 2 0 002 2z" fill="#00ff00"/>\
          <path d="M18 16v-5a6 6 0 10-12 0v5l-2 2h16l-2-2z" stroke="#00ff00" stroke-width="2" fill="none"/>\
        </svg>';
      }

      // Set initial theme toggle icon (action: switch to light → sun)
      (function initIcons() {
        const themeBtn = document.getElementById("themeBtn");
        if (themeBtn) themeBtn.innerHTML = getSunIcon();
        const searchBtn = document.getElementById("searchToggleBtn");
        if (searchBtn) searchBtn.innerHTML = getSearchIcon();
        const notifyBtn = document.getElementById("notifyToggleBtn");
        if (notifyBtn) notifyBtn.innerHTML = getBellIcon();
      })();

      // Store citations data
      let citations = [];
      let markers = [];
      const citationToMarker = new Map();
      let usedCoordinates = new Map(); // Track coordinates to avoid overlap
      let currentTimeFilter = "all"; // Track current time filter
      let isSearchActive = false;
      let searchCenter = null; // {lat, lon}
      let searchCircle = null;
      let pendingPick = false;

      // Search UI logic
      (function initSearchUI() {
        const toggleBtn = document.getElementById("searchToggleBtn");
        const panel = document.getElementById("searchPanel");
        const hint = document.getElementById("searchHint");
        const modeEl = document.getElementById("searchMode");
        const plateInputs = document.getElementById("plateInputs");
        const citationInputs = document.getElementById("citationInputs");
        const locationInputs = document.getElementById("locationInputs");
        const pickBtn = document.getElementById("pickLocationBtn");
        const useMyLocationBtn = document.getElementById("useMyLocationBtn");
        const searchBtn = document.getElementById("searchBtn");
        const clearBtn = document.getElementById("clearSearchBtn");
        const radiusEl = document.getElementById("searchRadiusMeters");
        let previousFilter = currentTimeFilter;

        if (toggleBtn && panel) {
          toggleBtn.addEventListener("click", () => {
            const opening = panel.style.display === "none";
            panel.style.display = opening ? "flex" : "none";
            if (!opening) {
              // Collapsing: restore previous view
              isSearchActive = false;
              if (searchCircle) {
                map.removeLayer(searchCircle);
                searchCircle = null;
              }
              showOnlyMarkers(citations);
              filterByTime(previousFilter);
              if (hint) hint.style.display = "none";
            } else {
              previousFilter = currentTimeFilter;
            }
          });
        }
        function getSinceIsoFromFilter() {
          // Map currentTimeFilter to a cutoff ISO string; return null for "all"
          try {
            if (
              currentTimeFilter === "hour" ||
              currentTimeFilter === "day" ||
              currentTimeFilter === "week"
            ) {
              const now = new Date();
              let ms = 0;
              if (currentTimeFilter === "hour") ms = 60 * 60 * 1000;
              else if (currentTimeFilter === "day") ms = 24 * 60 * 60 * 1000;
              else if (currentTimeFilter === "week")
                ms = 7 * 24 * 60 * 60 * 1000;
              const cutoff = new Date(now.getTime() - ms);
              return cutoff.toISOString();
            }
          } catch (_) {}
          return null;
        }

        function flashSearchHint() {
          const el = document.getElementById("searchHint");
          if (!el) return;
          el.style.display = "block";
          el.classList.remove("flash");
          // restart animation
          void el.offsetWidth;
          el.classList.add("flash");
          setTimeout(() => {
            el.classList.remove("flash");
            el.style.display = "none";
          }, 1800);
        }

        function updateInputs() {
          const mode = modeEl.value;
          plateInputs.style.display = mode === "plate" ? "inline-flex" : "none";
          citationInputs.style.display =
            mode === "citation" ? "inline" : "none";
          locationInputs.style.display =
            mode === "location" ? "inline-flex" : "none";
          if (mode === "location") {
            if (radiusEl) radiusEl.classList.add("highlight");
            flashSearchHint();
          } else if (hint) {
            hint.style.display = "none";
            if (radiusEl) radiusEl.classList.remove("highlight");
          }
        }

        modeEl.addEventListener("change", updateInputs);
        updateInputs();

        pickBtn.addEventListener("click", () => {
          pendingPick = true;
          document.getElementById("searchPickedLocationText").textContent =
            "tap map to set center";
          flashSearchHint();
          if (map && map._container) map._container.style.cursor = "crosshair";
        });

        // Geolocation helper
        async function getCurrentPosition() {
          return new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
              return reject(new Error("geolocation not supported"));
            }
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 8000,
              maximumAge: 0,
            });
          });
        }

        if (useMyLocationBtn) {
          useMyLocationBtn.addEventListener("click", async () => {
            try {
              const pos = await getCurrentPosition();
              searchCenter = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude,
              };
              document.getElementById(
                "searchPickedLocationText"
              ).textContent = `center: ${searchCenter.lat.toFixed(
                5
              )}, ${searchCenter.lon.toFixed(5)}`;
              const radiusM = parseFloat(radiusEl.value || "0");
              if (searchCircle) map.removeLayer(searchCircle);
              if (radiusM > 0) {
                searchCircle = L.circle([searchCenter.lat, searchCenter.lon], {
                  radius: radiusM,
                  color: "#00ff00",
                }).addTo(map);
              }
              map.setView([searchCenter.lat, searchCenter.lon], 15);
              // Auto-run search
              let url = "/api/search?mode=location";
              url += `&lat=${encodeURIComponent(
                searchCenter.lat
              )}&lon=${encodeURIComponent(
                searchCenter.lon
              )}&radius_m=${encodeURIComponent(radiusM)}`;
              const sinceIso1 = getSinceIsoFromFilter();
              if (sinceIso1) {
                url += `&since=${encodeURIComponent(sinceIso1)}`;
              }
              const resp = await fetch(url);
              const data = await resp.json();
              if (data.status !== "success") return;
              isSearchActive = true;
              const results = data.citations || [];
              showOnlyMarkers(results);
              const noResultsMsg = document.getElementById("noResultsMessage");
              const intervalEl = document.getElementById("noResultsInterval");
              if (!results.length) {
                if (intervalEl) intervalEl.textContent = "NO MATCHES FOUND";
                if (noResultsMsg) noResultsMsg.classList.add("visible");
              } else if (noResultsMsg) {
                noResultsMsg.classList.remove("visible");
              }
            } catch (_) {
              // ignore geolocation errors silently
            }
          });
        }

        map.on("click", (e) => {
          // When in location mode on mobile, allow tap-to-pick without pressing PICK
          const isLocationMode = modeEl && modeEl.value === "location";
          if (!pendingPick && !isLocationMode) return;
          pendingPick = false;
          searchCenter = { lat: e.latlng.lat, lon: e.latlng.lng };
          document.getElementById(
            "searchPickedLocationText"
          ).textContent = `center: ${searchCenter.lat.toFixed(
            5
          )}, ${searchCenter.lon.toFixed(5)}`;
          const radiusM = parseFloat(
            document.getElementById("searchRadiusMeters").value || "0"
          );
          if (searchCircle) {
            map.removeLayer(searchCircle);
          }
          if (radiusM > 0) {
            searchCircle = L.circle([searchCenter.lat, searchCenter.lon], {
              radius: radiusM,
              color: "#00ff00",
            }).addTo(map);
          }
          if (hint) hint.style.display = "none";
          if (map && map._container) map._container.style.cursor = "";
          // Auto-run location search after picking center
          (async () => {
            try {
              const mode = "location";
              let url = "/api/search?mode=" + mode;
              const radiusM = parseFloat(radiusEl.value || "0");
              url += `&lat=${encodeURIComponent(
                searchCenter.lat
              )}&lon=${encodeURIComponent(
                searchCenter.lon
              )}&radius_m=${encodeURIComponent(radiusM)}`;
              const sinceIso2 = getSinceIsoFromFilter();
              if (sinceIso2) {
                url += `&since=${encodeURIComponent(sinceIso2)}`;
              }
              const resp = await fetch(url);
              const data = await resp.json();
              if (data.status !== "success") return;
              isSearchActive = true;
              const results = data.citations || [];
              showOnlyMarkers(results);
              if (!results.length) {
                const noResultsMsg =
                  document.getElementById("noResultsMessage");
                const intervalEl = document.getElementById("noResultsInterval");
                if (intervalEl) intervalEl.textContent = "NO MATCHES FOUND";
                if (noResultsMsg) noResultsMsg.classList.add("visible");
                return;
              }
              if (results.length === 1) {
                const only = results[0];
                const marker = citationToMarker.get(
                  String(only.citation_number)
                );
                if (marker && only.latitude && only.longitude) {
                  const lat = parseFloat(only.latitude);
                  const lon = parseFloat(only.longitude);
                  map.setView([lat, lon], 16);
                  marker.openPopup();
                  showCitationDetails(only);
                }
              } else {
                const noResultsMsg =
                  document.getElementById("noResultsMessage");
                if (noResultsMsg) noResultsMsg.classList.remove("visible");
              }
            } catch (err) {
              console.error("search error", err);
            }
          })();
        });

        // Live update circle when radius changes
        radiusEl.addEventListener("input", () => {
          const val = parseFloat(radiusEl.value || "0");
          if (searchCircle && !isNaN(val)) {
            searchCircle.setRadius(val);
          }
        });

        // Inline +/- buttons for search radius
        const searchMinus = document.getElementById("searchRadiusMinus");
        const searchPlus = document.getElementById("searchRadiusPlus");
        let searchDebounce = null;
        function adjustSearchRadius(delta) {
          const current = parseFloat(radiusEl.value || "0") || 0;
          const next = Math.max(10, Math.min(100000, current + delta));
          radiusEl.value = String(Math.round(next));
          radiusEl.dispatchEvent(new Event("input"));
          if (isNaN(next) || !searchCenter) return;
          if (searchDebounce) clearTimeout(searchDebounce);
          searchDebounce = setTimeout(async () => {
            try {
              let url = "/api/search?mode=location";
              url += `&lat=${encodeURIComponent(
                searchCenter.lat
              )}&lon=${encodeURIComponent(
                searchCenter.lon
              )}&radius_m=${encodeURIComponent(next)}`;
              const sinceIso3 = getSinceIsoFromFilter();
              if (sinceIso3) {
                url += `&since=${encodeURIComponent(sinceIso3)}`;
              }
              const resp = await fetch(url);
              const data = await resp.json();
              if (data.status !== "success") return;
              isSearchActive = true;
              const results = data.citations || [];
              showOnlyMarkers(results);
              const noResultsMsg = document.getElementById("noResultsMessage");
              if (results.length === 0) {
                const intervalEl = document.getElementById("noResultsInterval");
                if (intervalEl) intervalEl.textContent = "NO MATCHES FOUND";
                if (noResultsMsg) noResultsMsg.classList.add("visible");
              } else {
                if (noResultsMsg) noResultsMsg.classList.remove("visible");
              }
            } catch (_) {}
          }, 300);
        }
        if (searchMinus)
          searchMinus.addEventListener("click", () => adjustSearchRadius(-50));
        if (searchPlus)
          searchPlus.addEventListener("click", () => adjustSearchRadius(50));

        searchBtn.addEventListener("click", async () => {
          // Reuse the same logic as auto-search
          const mode = modeEl.value;
          try {
            let url = "/api/search?mode=" + encodeURIComponent(mode);
            if (mode === "plate") {
              const state = (
                document.getElementById("searchPlateState").value || ""
              ).trim();
              const number = (
                document.getElementById("searchPlateNumber").value || ""
              ).trim();
              if (!state || !number) return;
              url += `&plate_state=${encodeURIComponent(
                state
              )}&plate_number=${encodeURIComponent(number)}`;
            } else if (mode === "citation") {
              const cnum = (
                document.getElementById("searchCitationNumber").value || ""
              ).trim();
              if (!cnum) return;
              url += `&citation_number=${encodeURIComponent(cnum)}`;
            } else if (mode === "location") {
              const radiusM = parseFloat(radiusEl.value || "0");
              if (!searchCenter) return;
              url += `&lat=${encodeURIComponent(
                searchCenter.lat
              )}&lon=${encodeURIComponent(
                searchCenter.lon
              )}&radius_m=${encodeURIComponent(radiusM)}`;
            }

            const sinceIso4 = getSinceIsoFromFilter();
            if (sinceIso4) {
              url += `&since=${encodeURIComponent(sinceIso4)}`;
            }

            const resp = await fetch(url);
            const data = await resp.json();
            if (data.status !== "success") return;

            isSearchActive = true;
            const results = data.citations || [];
            showOnlyMarkers(results);
            updateRadiusDisplay(
              mode === "location" ? radiusEl.value || "0" : null
            );

            if (!results.length) {
              const noResultsMsg = document.getElementById("noResultsMessage");
              const intervalEl = document.getElementById("noResultsInterval");
              if (intervalEl) intervalEl.textContent = "NO MATCHES FOUND";
              if (noResultsMsg) noResultsMsg.classList.add("visible");
              return;
            }

            if (results.length === 1) {
              const only = results[0];
              const marker = citationToMarker.get(String(only.citation_number));
              if (marker && only.latitude && only.longitude) {
                const lat = parseFloat(only.latitude);
                const lon = parseFloat(only.longitude);
                map.setView([lat, lon], 16);
                marker.openPopup();
                showCitationDetails(only);
              }
            } else {
              const noResultsMsg = document.getElementById("noResultsMessage");
              if (noResultsMsg) noResultsMsg.classList.remove("visible");
            }
          } catch (err) {
            console.error("search error", err);
          }
        });

        clearBtn.addEventListener("click", () => {
          isSearchActive = false;
          if (searchCircle) {
            map.removeLayer(searchCircle);
            searchCircle = null;
          }
          // Reset to full dataset
          showOnlyMarkers(citations);
          filterByTime(previousFilter);
          if (panel) panel.style.display = "none";
          if (hint) hint.style.display = "none";
          const noResultsMsg = document.getElementById("noResultsMessage");
          if (noResultsMsg) noResultsMsg.classList.remove("visible");
        });
      })();

      function clearAllMarkers() {
        markers.forEach((m) => {
          if (map.hasLayer(m)) m.removeFrom(map);
        });
        markers = [];
        citationToMarker.clear();
        usedCoordinates = new Map();
      }

      function showOnlyMarkers(list) {
        clearAllMarkers();
        list.forEach((c) => {
          const m = createMarkerForCitation(c);
          if (m) markers.push(m);
        });
        focusMap();

        // Update stats and legend based on the provided list (search results)
        try {
          // Total citations and total amount
          const totalCount = list.length;
          document.getElementById("totalCitations").textContent =
            totalCount.toLocaleString();
          const totalAmount = list.reduce(
            (sum, c) => sum + (parseFloat(c.amount_due) || 0),
            0
          );
          document.getElementById("totalAmount").textContent =
            "$" +
            totalAmount.toLocaleString(undefined, {
              minimumFractionDigits: 0,
              maximumFractionDigits: 0,
            });

          // Legend buckets
          let redCount = 0; // >= $50
          let orangeCount = 0; // >= $30
          let greenCount = 0; // < $30
          list.forEach((citation) => {
            const amount = parseFloat(citation.amount_due) || 0;
            if (amount >= 50) redCount++;
            else if (amount >= 30) orangeCount++;
            else greenCount++;
          });
          document.getElementById("legendRed").textContent =
            redCount.toLocaleString();
          document.getElementById("legendOrange").textContent =
            orangeCount.toLocaleString();
          document.getElementById("legendGreen").textContent =
            greenCount.toLocaleString();
        } catch (_) {
          // no-op if elements not found
        }
      }

      // Header recent time: fixed-length scramble during load, gentle decode reveal
      let recentScrambleTimer = null;
      let recentScrambleTargetLength = null;
      function startRecentScramble(targetLength) {
        const el = document.getElementById("recentCitationTime");
        if (!el) return;
        if (recentScrambleTimer) clearInterval(recentScrambleTimer);
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:, ";
        recentScrambleTargetLength = targetLength || 22; // fallback length
        recentScrambleTimer = setInterval(() => {
          let s = "";
          for (let i = 0; i < recentScrambleTargetLength; i++) {
            s += chars[Math.floor(Math.random() * chars.length)];
          }
          el.textContent = s;
        }, 70); // smooth, not jarring
      }

      function revealRecentTime(finalText) {
        const el = document.getElementById("recentCitationTime");
        if (!el) return;
        if (recentScrambleTimer) {
          clearInterval(recentScrambleTimer);
          recentScrambleTimer = null;
        }
        const target = finalText;
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:, ";
        const currentScrambled = el.textContent; // keep the current scramble
        const length = target.length;
        // Ensure we have the right length array
        let result =
          currentScrambled.length === length
            ? Array.from(currentScrambled)
            : Array.from(
                { length: length },
                () => chars[Math.floor(Math.random() * chars.length)]
              );
        let index = 0;
        const interval = setInterval(() => {
          // Replace characters in place from left to right
          if (index < length) {
            result[index] = target[index];
            index++;
          }
          // Keep scrambling the remaining characters
          for (let i = index; i < length; i++) {
            result[i] = chars[Math.floor(Math.random() * chars.length)];
          }
          el.textContent = result.join("");
          if (index >= length) {
            clearInterval(interval);
            el.textContent = target;
          }
        }, 50);
      }

      // Load citations from API
      async function loadCitations() {
        // Estimate final length using the same formatter on current time
        const estimateFormatter = new Intl.DateTimeFormat("en-US", {
          timeZone: "America/Detroit",
          month: "short",
          day: "numeric",
          year: "numeric",
          hour: "numeric",
          minute: "2-digit",
          hour12: true,
        });
        const estimated = `LATEST: ${estimateFormatter.format(new Date())}`;
        startRecentScramble(estimated.length);
        try {
          const response = await fetch("/api/citations");
          const data = await response.json();

          if (data.status === "success") {
            citations = data.citations || [];

            // Show error message if there's an auth issue
            if (
              data.error &&
              (data.error.includes("authentication") ||
                data.error.includes("SUPABASE_SERVICE_ROLE_KEY"))
            ) {
              document.getElementById("loading").innerHTML = `
                 <div style="background: rgba(255, 59, 48, 0.9); padding: 20px 30px; border-radius: 16px; color: #fff; max-width: 500px; text-align: center;">
                   <div style="font-size: 24px; margin-bottom: 10px;">🔒</div>
                   <strong>Authentication Required</strong><br>
                   <div style="margin-top: 10px; font-size: 13px;">
                     Please add SUPABASE_SERVICE_ROLE_KEY to your environment variables.<br>
                     See <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">FIX_AUTH_ISSUE.md</code> for instructions.
                   </div>
                 </div>
               `;
              return;
            }

            // Show message if no citations with coordinates
            if (citations.length === 0) {
              if (data.total > 0) {
                document.getElementById("loading").innerHTML = `
                   <div style="background: rgba(255, 149, 0, 0.9); padding: 20px 30px; border-radius: 16px; color: #fff; max-width: 500px; text-align: center;">
                     <div style="font-size: 24px; margin-bottom: 10px;">📍</div>
                     <strong>No Geocoded Citations</strong><br>
                     <div style="margin-top: 10px; font-size: 13px;">
                       Found ${data.total} citations but none have coordinates.<br>
                       Run: <code style="background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px;">python geocode_citations.py</code>
                     </div>
                   </div>
                 `;
                document.getElementById("totalCitations").textContent = "0";
                document.getElementById("totalAmount").textContent = "$0";
                return;
              }
            }

            // Update stats
            document.getElementById("totalCitations").textContent =
              citations.length.toLocaleString();
            const totalAmount = citations.reduce(
              (sum, c) => sum + (parseFloat(c.amount_due) || 0),
              0
            );
            document.getElementById("totalAmount").textContent =
              "$" +
              totalAmount.toLocaleString(undefined, {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0,
              });

            // Compute today's stats in America/Detroit
            const detroitTZ = "America/Detroit";
            const nowDetroit = new Date(
              new Intl.DateTimeFormat("en-US", { timeZone: detroitTZ }).format(
                new Date()
              )
            );
            const todayDetroitStr = new Intl.DateTimeFormat("en-CA", {
              timeZone: detroitTZ,
              year: "numeric",
              month: "2-digit",
              day: "2-digit",
            }).format(new Date());

            let countToday = 0;
            let amountToday = 0;
            citations.forEach((c) => {
              if (!c.issue_date) return;
              const d = new Date(c.issue_date);
              const dStr = new Intl.DateTimeFormat("en-CA", {
                timeZone: detroitTZ,
                year: "numeric",
                month: "2-digit",
                day: "2-digit",
              }).format(d);
              if (dStr === todayDetroitStr) {
                countToday += 1;
                amountToday += parseFloat(c.amount_due) || 0;
              }
            });
            document.getElementById("totalCitationsToday").textContent =
              countToday.toLocaleString();
            document.getElementById("totalAmountToday").textContent =
              "$" +
              amountToday.toLocaleString(undefined, {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0,
              });

            // Update most recent citation time (America/Detroit)
            if (data.most_recent_citation_time) {
              const recent = new Date(data.most_recent_citation_time);

              if (!isNaN(recent.getTime())) {
                // Format with timeZone: 'America/Detroit' converts UTC to Eastern Time
                const formatter = new Intl.DateTimeFormat("en-US", {
                  timeZone: "America/Detroit",
                  month: "short",
                  day: "numeric",
                  year: "numeric",
                  hour: "numeric",
                  minute: "2-digit",
                  hour12: true,
                });
                const formattedTime = formatter.format(recent);
                revealRecentTime(`LATEST: ${formattedTime}`);
                const el = document.getElementById("recentCitationTime");
                if (el) {
                  el.style.cursor = "pointer";
                  el.title = "Jump to latest citation";
                  el.onclick = () => focusLatestCitation();
                }
              }
            }

            // Calculate legend counts
            let redCount = 0; // >= $50
            let orangeCount = 0; // >= $30
            let greenCount = 0; // < $30

            citations.forEach((citation) => {
              const amount = parseFloat(citation.amount_due) || 0;
              if (amount >= 50) {
                redCount++;
              } else if (amount >= 30) {
                orangeCount++;
              } else {
                greenCount++;
              }
            });

            // Update legend counts
            document.getElementById("legendRed").textContent =
              redCount.toLocaleString();
            document.getElementById("legendOrange").textContent =
              orangeCount.toLocaleString();
            document.getElementById("legendGreen").textContent =
              greenCount.toLocaleString();

            // Geocode and place markers
            await placeMarkers();

            // Hide loading
            document.getElementById("loading").style.display = "none";
          }
        } catch (error) {
          console.error("Error loading citations:", error);
          document.getElementById("loading").textContent =
            "Error loading citations";
        }
      }

      // Get offset for duplicate coordinates
      function getOffsetCoordinates(lat, lon) {
        const coordKey = `${lat.toFixed(6)},${lon.toFixed(6)}`;

        if (!usedCoordinates.has(coordKey)) {
          usedCoordinates.set(coordKey, 1);
          return { lat, lon };
        }

        // If this coordinate is already used, add a small random offset
        const count = usedCoordinates.get(coordKey);
        usedCoordinates.set(coordKey, count + 1);

        // Create a spiral offset: each duplicate gets a slightly larger radius
        const angle = count * 137.5; // Golden angle for even distribution
        const distance = 0.00005 * count; // ~5 meters per duplicate
        const offsetLat = lat + Math.cos((angle * Math.PI) / 180) * distance;
        const offsetLon = lon + Math.sin((angle * Math.PI) / 180) * distance;

        return { lat: offsetLat, lon: offsetLon };
      }

      // Create marker for citation with coordinates
      function createMarkerForCitation(citation) {
        // Check if citation has coordinates
        if (!citation.latitude || !citation.longitude) {
          console.warn(
            "Citation missing coordinates:",
            citation.citation_number
          );
          return null;
        }

        const originalLat = parseFloat(citation.latitude);
        const originalLon = parseFloat(citation.longitude);

        // Get offset coordinates if duplicates exist
        const { lat, lon } = getOffsetCoordinates(originalLat, originalLon);

        // Create custom icon - Minimal style
        const amount = parseFloat(citation.amount_due) || 0;
        const color = getColorForAmount(citation.amount_due);
        const size = amount >= 50 ? 12 : amount >= 30 ? 10 : 8;
        const borderColor =
          amount >= 50 ? "#ff0040" : amount >= 30 ? "#ff8000" : "#00ff00";

        const customIcon = L.divIcon({
          className: "custom-marker",
          html: `<div style="width: 100%; height: 100%; background: ${color}; border: 1px solid ${borderColor};"></div>`,
          iconSize: [size, size],
          iconAnchor: [size / 2, size / 2],
        });

        // Create marker with retro terminal popup
        const marker = L.marker([lat, lon], { icon: customIcon })
          .bindPopup(
            `
                    <strong>▶ CITATION #${citation.citation_number}</strong><br>
                    ──────────────────────<br>
                    LOC: ${citation.location || "UNKNOWN"}<br>
                    AMT: $${(parseFloat(citation.amount_due) || 0).toFixed(
                      2
                    )}<br>
                    PLT: ${citation.plate_state || ""} ${
              citation.plate_number || ""
            }<br>
                    ──────────────────────
                `,
            {
              className: "terminal-popup",
            }
          )
          .addTo(map);

        // Keep reference to the marker by citation number
        if (citation.citation_number) {
          citationToMarker.set(String(citation.citation_number), marker);
        }

        // Add click handler - auto-focus and show side panel
        marker.on("click", () => {
          // Auto-focus on original coordinates (not offset)
          map.setView([originalLat, originalLon], 16);

          // Show side panel with citation details
          showCitationDetails(citation);
        });

        return marker;
      }

      // Focus and open the latest citation
      function focusLatestCitation() {
        if (!citations.length) return;
        let latest = citations[0];
        for (const c of citations) {
          if (new Date(c.issue_date) > new Date(latest.issue_date)) latest = c;
        }
        const marker = citationToMarker.get(String(latest.citation_number));
        if (marker) {
          const lat = parseFloat(latest.latitude);
          const lon = parseFloat(latest.longitude);
          map.setView([lat, lon], 16);
          marker.openPopup();
          showCitationDetails(latest);
        }
      }

      // Get color based on amount - Minimal opacity
      function getColorForAmount(amount) {
        const amt = parseFloat(amount) || 0;
        if (amt >= 50) return "rgba(255, 0, 64, 0.7)"; // Red with opacity
        if (amt >= 30) return "rgba(255, 128, 0, 0.7)"; // Orange with opacity
        return "rgba(0, 255, 0, 0.7)"; // Green with opacity
      }

      // Place all markers
      async function placeMarkers() {
        // Create markers for all citations
        citations.forEach((citation) => {
          const marker = createMarkerForCitation(citation);
          if (marker) {
            markers.push(marker);
          }
        });
      }

      // Focus map on markers
      function focusMap() {
        if (markers.length > 0) {
          const group = new L.featureGroup(markers);
          map.fitBounds(group.getBounds().pad(0.1));
        }
      }

      // Reset view to Ann Arbor
      function resetView() {
        map.setView([42.2808, -83.743], 13);
      }

      // Show citation details in side panel
      function showCitationDetails(citation) {
        const panel = document.getElementById("sidePanel");
        const title = document.getElementById("sidePanelTitle");
        const content = document.getElementById("sidePanelContent");

        // Check if mobile
        const isMobile = window.matchMedia && window.matchMedia("(max-width: 768px)").matches;
        
        if (isMobile) {
          // On mobile: just slide up from bottom, no layout shift
          panel.classList.add("active");
          document.body.classList.add("mobile-panel-open"); // For map controls positioning
          // Don't add panel-open class on mobile to prevent layout shifts
        } else {
          // On desktop: shift layout as before
          panel.classList.add("active");
          document.body.classList.add("panel-open");
        }

        title.textContent = `CITATION #${citation.citation_number}`;

        content.innerHTML = `
           <div class="info-item">
             <div class="info-label">LOCATION</div>
             <div class="info-value">${citation.location || "Unknown"}</div>
           </div>
           <div class="info-item">
             <div class="info-label">ISSUE DATE</div>
             <div class="info-value">${new Intl.DateTimeFormat("en-US", {
               timeZone: "America/Detroit",
               month: "short",
               day: "numeric",
               year: "numeric",
               hour: "numeric",
               minute: "2-digit",
               hour12: true,
             }).format(new Date(citation.issue_date))}</div>
           </div>
           <div class="info-item">
             <div class="info-label">AMOUNT DUE</div>
             <div class="info-value">$${(
               parseFloat(citation.amount_due) || 0
             ).toFixed(2)}</div>
           </div>
           <div class="info-item">
             <div class="info-label">PLATE</div>
             <div class="info-value">${citation.plate_state || ""} ${
          citation.plate_number || ""
        }</div>
           </div>
           ${
             citation.violations && citation.violations.length > 0
               ? `
           <div class="info-item">
             <div class="info-label">VIOLATIONS</div>
             <div class="info-value">${
               Array.isArray(citation.violations)
                 ? citation.violations.join(", ")
                 : citation.violations
             }</div>
           </div>
           `
               : ""
           }
           ${
             citation.comments
               ? `
           <div class="info-item">
             <div class="info-label">COMMENTS</div>
             <div class="info-value">${citation.comments}</div>
           </div>
           `
               : ""
           }
           ${
             citation.more_info_url
               ? `
           <div class="info-item">
             <div class="info-label"></div>
             <div class="info-value"><a href="${citation.more_info_url}" target="_blank" style="color: #00ff00;">VIEW MORE INFO →</a></div>
           </div>
           `
               : ""
           }
         `;
      }

      // Toggle between light and dark mode
      function toggleTheme() {
        isDarkMode = !isDarkMode;

        // Remove current tile layer
        map.removeLayer(currentTileLayer);

        if (isDarkMode) {
          // Dark theme
          currentTileLayer = L.tileLayer(
            "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
            {
              attribution:
                '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
              subdomains: "abcd",
              maxZoom: 20,
            }
          );
          document.getElementById("themeBtn").innerHTML = getSunIcon();
        } else {
          // Light theme
          currentTileLayer = L.tileLayer(
            "https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png",
            {
              attribution:
                '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
              subdomains: "abcd",
              maxZoom: 20,
            }
          );
          document.getElementById("themeBtn").innerHTML = getMoonIcon();
        }

        currentTileLayer.addTo(map);
      }

      // Filter citations by time period
      function filterByTime(period) {
        if (isSearchActive) {
          // Ignore time filter while search is active
          return;
        }
        currentTimeFilter = period;

        // Update button states
        document.querySelectorAll(".time-filter-btn").forEach((btn) => {
          btn.classList.remove("active");
          if (btn.dataset.time === period) {
            btn.classList.add("active");
          }
        });

        // Hide no results message initially
        const noResultsMsg = document.getElementById("noResultsMessage");
        noResultsMsg.classList.remove("visible");

        // Calculate cutoff time in America/Detroit timezone
        const detroitTZ = "America/Detroit";
        const nowDetroit = new Date();

        let cutoffTime;
        if (period === "hour") {
          cutoffTime = new Date(nowDetroit.getTime() - 60 * 60 * 1000);
        } else if (period === "day") {
          cutoffTime = new Date(nowDetroit.getTime() - 24 * 60 * 60 * 1000);
        } else if (period === "week") {
          cutoffTime = new Date(nowDetroit.getTime() - 7 * 24 * 60 * 60 * 1000);
        } else {
          cutoffTime = null; // Show all
        }

        // Filter and show/hide markers
        let visibleCount = 0;
        citations.forEach((citation) => {
          if (!citation.citation_number) return;

          const marker = citationToMarker.get(String(citation.citation_number));
          if (!marker) return;

          if (cutoffTime === null) {
            // Show all
            if (!map.hasLayer(marker)) {
              marker.addTo(map);
            }
            visibleCount++;
          } else {
            // Check if citation issue_date is within the time period
            if (citation.issue_date) {
              const issueDate = new Date(citation.issue_date);
              if (issueDate >= cutoffTime) {
                if (!map.hasLayer(marker)) {
                  marker.addTo(map);
                }
                visibleCount++;
              } else {
                if (map.hasLayer(marker)) {
                  marker.removeFrom(map);
                }
              }
            } else {
              // No issue date, hide it
              if (map.hasLayer(marker)) {
                marker.removeFrom(map);
              }
            }
          }
        });

        // Show no results message if no citations found
        if (visibleCount === 0 && period !== "all") {
          let intervalText = "";
          if (period === "hour") {
            intervalText = "NONE FOUND IN THE LAST HOUR";
          } else if (period === "day") {
            intervalText = "NONE FOUND IN THE LAST 24 HOURS";
          } else if (period === "week") {
            intervalText = "NONE FOUND IN THE LAST WEEK";
          }
          document.getElementById("noResultsInterval").textContent =
            intervalText;
          noResultsMsg.classList.add("visible");
        } else {
          noResultsMsg.classList.remove("visible");
        }

        // Update stats based on visible citations
        updateStatsForFilter(period, cutoffTime);
      }

      // Update statistics for filtered citations
      function updateStatsForFilter(period, cutoffTime) {
        let filteredCitations = citations;

        if (cutoffTime !== null) {
          filteredCitations = citations.filter((c) => {
            if (!c.issue_date) return false;
            const issueDate = new Date(c.issue_date);
            return issueDate >= cutoffTime;
          });
        }

        // Update total citations and amount
        document.getElementById("totalCitations").textContent =
          filteredCitations.length.toLocaleString();
        const totalAmount = filteredCitations.reduce(
          (sum, c) => sum + (parseFloat(c.amount_due) || 0),
          0
        );
        document.getElementById("totalAmount").textContent =
          "$" +
          totalAmount.toLocaleString(undefined, {
            minimumFractionDigits: 0,
            maximumFractionDigits: 0,
          });

        // Update legend counts for filtered citations
        let redCount = 0;
        let orangeCount = 0;
        let greenCount = 0;

        filteredCitations.forEach((citation) => {
          const amount = parseFloat(citation.amount_due) || 0;
          if (amount >= 50) {
            redCount++;
          } else if (amount >= 30) {
            orangeCount++;
          } else {
            greenCount++;
          }
        });

        document.getElementById("legendRed").textContent =
          redCount.toLocaleString();
        document.getElementById("legendOrange").textContent =
          orangeCount.toLocaleString();
        document.getElementById("legendGreen").textContent =
          greenCount.toLocaleString();
      }

      // Initialize filter button - set "all" as active
      (function initFilterButtons() {
        const filterAllBtn = document.getElementById("filterAll");
        if (filterAllBtn) {
          filterAllBtn.classList.add("active");
        }
      })();

      // Load citations on page load
      loadCitations();

      // Notifications UI (bell)
      (function initNotifyUI() {
        const toggleBtn = document.getElementById("notifyToggleBtn");
        const panel = document.getElementById("notifyPanel");
        const modeEl = document.getElementById("notifyMode");
        const plateRow = document.getElementById("notifyPlate");
        const locRow = document.getElementById("notifyLocation");
        const pickBtn = document.getElementById("notifyPickCenterBtn");
        const useMyLocationBtn = document.getElementById(
          "notifyUseMyLocationBtn"
        );
        const radiusEl = document.getElementById("notifyRadiusMeters");
        const pickedText = document.getElementById("notifyPickedText");
        const submitBtn = document.getElementById("notifySubmitBtn");
        const msg = document.getElementById("notifyMsg");
        const searchPanel = document.getElementById("searchPanel");
        const searchHint = document.getElementById("searchHint");
        let pendingPickNotify = false;
        let notifyCircle = null;

        // Add a subtle subscribe tip if not present
        if (panel && !document.getElementById("notifyTip")) {
          const tip = document.createElement("div");
          tip.id = "notifyTip";
          tip.style.cssText =
            "margin-top:6px; padding:8px; border:1px dashed #00ff00; color:#00ff00; font-size:10px; background:rgba(0,255,0,0.05)";
          tip.textContent =
            "Tip: Subscribe by plate, or pick a center & radius to get alerts for that area.";
          panel.appendChild(tip);
        }

        function updateNotifyInputs() {
          const mode = modeEl.value;
          plateRow.style.display = mode === "plate" ? "flex" : "none";
          locRow.style.display = mode === "location" ? "flex" : "none";
          msg.textContent = "";

          // Visual cue for location notifications
          if (mode === "location") {
            if (searchHint) searchHint.style.bottom = "180px"; // move up to avoid overlap
            const r = parseFloat(radiusEl.value || "0");
            if (searchCenter && !isNaN(r) && r > 0) {
              if (notifyCircle) map.removeLayer(notifyCircle);
              notifyCircle = L.circle([searchCenter.lat, searchCenter.lon], {
                radius: r,
                color: "#00ffff",
                dashArray: "6 6",
              }).addTo(map);
            }
          } else {
            if (searchHint) searchHint.style.bottom = "100px";
            if (notifyCircle) {
              map.removeLayer(notifyCircle);
              notifyCircle = null;
            }
          }
        }
        modeEl.addEventListener("change", updateNotifyInputs);
        updateNotifyInputs();

        if (toggleBtn && panel) {
          toggleBtn.addEventListener("click", () => {
            const opening = panel.style.display === "none";
            panel.style.display = opening ? "flex" : "none";
            if (opening) {
              // Close search panel for clean UX
              if (searchPanel) searchPanel.style.display = "none";
              // Reset any active search state
              isSearchActive = false;
              if (searchCircle) {
                map.removeLayer(searchCircle);
                searchCircle = null;
              }
              showOnlyMarkers(citations);
              updateNotifyInputs();
            } else {
              msg.textContent = "";
              if (searchHint) searchHint.style.bottom = "100px";
              if (notifyCircle) {
                map.removeLayer(notifyCircle);
                notifyCircle = null;
              }
            }
          });
        }

        pickBtn.addEventListener("click", () => {
          pendingPickNotify = true;
          pickedText.textContent = "tap map to set center";
          if (searchHint) searchHint.style.bottom = "180px";
          if (map && map._container) map._container.style.cursor = "crosshair";
        });

        map.on("click", (e) => {
          if (!pendingPickNotify) return;
          pendingPickNotify = false;
          searchCenter = { lat: e.latlng.lat, lon: e.latlng.lng };
          pickedText.textContent = `center: ${searchCenter.lat.toFixed(
            5
          )}, ${searchCenter.lon.toFixed(5)}`;
          // Draw/update cyan preview circle
          const r = parseFloat(radiusEl.value || "0");
          if (notifyCircle) map.removeLayer(notifyCircle);
          if (!isNaN(r) && r > 0) {
            notifyCircle = L.circle([searchCenter.lat, searchCenter.lon], {
              radius: r,
              color: "#00ffff",
              dashArray: "6 6",
            }).addTo(map);
          }
          if (map && map._container) map._container.style.cursor = "";
        });

        if (useMyLocationBtn) {
          useMyLocationBtn.addEventListener("click", async () => {
            try {
              const pos = await (async () =>
                new Promise((resolve, reject) => {
                  if (!navigator.geolocation) {
                    return reject(new Error("geolocation not supported"));
                  }
                  navigator.geolocation.getCurrentPosition(resolve, reject, {
                    enableHighAccuracy: true,
                    timeout: 8000,
                    maximumAge: 0,
                  });
                }))();
              searchCenter = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude,
              };
              pickedText.textContent = `center: ${searchCenter.lat.toFixed(
                5
              )}, ${searchCenter.lon.toFixed(5)}`;
              const r = parseFloat(radiusEl.value || "0");
              if (notifyCircle) map.removeLayer(notifyCircle);
              if (!isNaN(r) && r > 0) {
                notifyCircle = L.circle([searchCenter.lat, searchCenter.lon], {
                  radius: r,
                  color: "#00ffff",
                  dashArray: "6 6",
                }).addTo(map);
              }
              map.setView([searchCenter.lat, searchCenter.lon], 15);
            } catch (_) {
              // ignore geolocation errors silently
            }
          });
        }

        // Live update preview when radius changes in notify panel
        radiusEl.addEventListener("input", () => {
          const r = parseFloat(radiusEl.value || "0");
          if (notifyCircle && !isNaN(r)) notifyCircle.setRadius(r);
        });

        // Inline +/- for notify radius
        const notifyMinus = document.getElementById("notifyRadiusMinus");
        const notifyPlus = document.getElementById("notifyRadiusPlus");
        function adjustNotifyRadius(delta) {
          const current = parseFloat(radiusEl.value || "0") || 0;
          const next = Math.max(10, Math.min(100000, current + delta));
          radiusEl.value = String(Math.round(next));
          radiusEl.dispatchEvent(new Event("input"));
        }
        if (notifyMinus)
          notifyMinus.addEventListener("click", () => adjustNotifyRadius(-50));
        if (notifyPlus)
          notifyPlus.addEventListener("click", () => adjustNotifyRadius(50));

        submitBtn.addEventListener("click", async () => {
          msg.style.color = "#888";
          msg.textContent = "";
          const email = (
            document.getElementById("notifyEmail").value || ""
          ).trim();
          if (!email) {
            msg.style.color = "#ff8080";
            msg.textContent = "Email is required";
            return;
          }
          // persist contact locally for convenience
          try {
            localStorage.setItem("notify_email", email || "");
          } catch (_) {}
          const mode = modeEl.value;
          let payload = {
            email: email,
          };
          if (mode === "plate") {
            const st = (document.getElementById("notifyPlateState").value || "")
              .trim()
              .toUpperCase();
            const pn = (
              document.getElementById("notifyPlateNumber").value || ""
            ).trim();
            if (!st || !pn) {
              msg.style.color = "#ff8080";
              msg.textContent = "Enter plate state and number";
              return;
            }
            payload.plate_state = st;
            payload.plate_number = pn;
          } else {
            const r = parseFloat(radiusEl.value || "0");
            if (!searchCenter || isNaN(r) || r <= 0) {
              msg.style.color = "#ff8080";
              msg.textContent = "Pick a center and set a positive radius";
              return;
            }
            payload.center_lat = searchCenter.lat;
            payload.center_lon = searchCenter.lon;
            payload.radius_m = r;
          }
          try {
            const resp = await fetch("/api/subscribe", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            const data = await resp.json().catch(() => ({}));
            if (resp.ok) {
              msg.style.color = "#80ff80";
              msg.textContent =
                mode === "plate"
                  ? "Subscribed: you'll get alerts when this plate is ticketed."
                  : "Subscribed: you'll get alerts for tickets in this area.";
            } else {
              msg.style.color = "#ff8080";
              msg.textContent = data.error || "Failed to subscribe";
            }
          } catch (err) {
            msg.style.color = "#ff8080";
            msg.textContent = "Network error";
          }
        });

        // Pre-fill contact from localStorage
        try {
          const savedEmail = localStorage.getItem("notify_email") || "";
          if (savedEmail)
            document.getElementById("notifyEmail").value = savedEmail;
        } catch (_) {}
      })();

      // On mobile, keep panels collapsed by default for simpler experience

      // (popup radius controls removed; radius +/- now inline in panels)

      (function updateMobileFilterLabels() {
        function setLabels(isMobile) {
          if (isMobile) {
            document.getElementById("filterAll").textContent = "ALL";
            document.getElementById("filterWeek").textContent = "WK";
            document.getElementById("filterDay").textContent = "24H";
            document.getElementById("filterHour").textContent = "1H";
          } else {
            document.getElementById("filterAll").textContent = "ALL";
            document.getElementById("filterWeek").textContent = "PAST WEEK";
            document.getElementById("filterDay").textContent = "PAST 24 HOURS";
            document.getElementById("filterHour").textContent = "PAST HOUR";
          }
        }
        function checkWidth() {
          setLabels(window.innerWidth <= 768);
        }
        window.addEventListener("resize", checkWidth);
        checkWidth();
      })();
    </script>
  </body>
</html>
